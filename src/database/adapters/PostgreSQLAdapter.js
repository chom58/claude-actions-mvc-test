const { Pool, Client } = require('pg');
const DatabaseAdapter = require('../DatabaseAdapter');
const QueryBuilder = require('../QueryBuilder');

/**
 * PostgreSQL „Éá„Éº„Çø„Éô„Éº„Çπ„Ç¢„ÉÄ„Éó„Çø„Éº
 */
class PostgreSQLAdapter extends DatabaseAdapter {
  constructor(config) {
    super(config);
    this.pool = null;
    this.client = null;
    this.queryBuilder = new QueryBuilder(this);
  }

  /**
   * „Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö
   */
  async connect() {
    try {
      // Êé•Á∂ö„Éó„Éº„É´„ÅÆË®≠ÂÆö
      const poolConfig = {
        host: this.config.host || 'localhost',
        port: this.config.port || 5432,
        database: this.config.database,
        user: this.config.username,
        password: this.config.password,
        max: this.config.pool?.max || 20,
        min: this.config.pool?.min || 5,
        idle: this.config.pool?.idle || 10000,
        acquire: this.config.pool?.acquire || 60000,
        evict: this.config.pool?.evict || 1000,
        ssl: this.config.ssl || false
      };

      this.pool = new Pool(poolConfig);
      
      // Êé•Á∂ö„ÉÜ„Çπ„Éà
      this.client = await this.pool.connect();
      await this.client.query('SELECT NOW()');
      this.client.release();
      
      this.isConnected = true;
      console.log('‚úÖ PostgreSQLÊé•Á∂öÊàêÂäü');
    } catch (error) {
      console.error('‚ùå PostgreSQLÊé•Á∂ö„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÇíÂàáÊñ≠
   */
  async disconnect() {
    try {
      if (this.pool) {
        await this.pool.end();
        this.pool = null;
      }
      this.isConnected = false;
      console.log('‚úÖ PostgreSQLÊé•Á∂öÂàáÊñ≠');
    } catch (error) {
      console.error('‚ùå PostgreSQLÂàáÊñ≠„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „ÇØ„Ç®„É™„ÇíÂÆüË°å
   */
  async query(query, params = []) {
    if (!this.pool) {
      throw new Error('„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
    }

    try {
      const start = Date.now();
      const result = await this.pool.query(query, params);
      const duration = Date.now() - start;

      // „É≠„Ç∞Âá∫ÂäõÔºàÈñãÁô∫Áí∞Â¢É„ÅÆ„ÅøÔºâ
      if (process.env.NODE_ENV === 'development') {
        console.log(`üîç SQLÂÆüË°å: ${duration}ms`, { query, params });
      }

      return {
        rows: result.rows,
        rowCount: result.rowCount,
        fields: result.fields,
        command: result.command
      };
    } catch (error) {
      console.error('‚ùå PostgreSQL„ÇØ„Ç®„É™„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÈñãÂßã
   */
  async beginTransaction() {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      return {
        client,
        async commit() {
          try {
            await client.query('COMMIT');
          } finally {
            client.release();
          }
        },
        async rollback() {
          try {
            await client.query('ROLLBACK');
          } finally {
            client.release();
          }
        },
        async query(sql, params) {
          return await client.query(sql, params);
        }
      };
    } catch (error) {
      client.release();
      throw error;
    }
  }

  /**
   * „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Çí„Ç≥„Éü„ÉÉ„Éà
   */
  async commitTransaction(transaction) {
    await transaction.commit();
  }

  /**
   * „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Çí„É≠„Éº„É´„Éê„ÉÉ„ÇØ
   */
  async rollbackTransaction(transaction) {
    await transaction.rollback();
  }

  /**
   * „ÉÜ„Éº„Éñ„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
   */
  async tableExists(tableName) {
    const query = `
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `;
    
    const result = await this.query(query, [tableName]);
    return result.rows[0].exists;
  }

  /**
   * „ÉÜ„Éº„Éñ„É´„Çí‰ΩúÊàê
   */
  async createTable(tableName, schema) {
    const columns = Object.entries(schema).map(([name, definition]) => {
      return `${name} ${this._convertDataType(definition)}`;
    }).join(', ');

    const query = `CREATE TABLE IF NOT EXISTS ${tableName} (${columns})`;
    await this.query(query);
  }

  /**
   * „ÉÜ„Éº„Éñ„É´„ÇíÂâäÈô§
   */
  async dropTable(tableName) {
    const query = `DROP TABLE IF EXISTS ${tableName} CASCADE`;
    await this.query(query);
  }

  /**
   * „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí‰ΩúÊàê
   */
  async createIndex(tableName, indexName, columns, options = {}) {
    const columnList = Array.isArray(columns) ? columns.join(', ') : columns;
    const unique = options.unique ? 'UNIQUE' : '';
    const method = options.method ? `USING ${options.method}` : '';
    
    const query = `
      CREATE ${unique} INDEX IF NOT EXISTS ${indexName} 
      ON ${tableName} ${method} (${columnList})
    `;
    
    await this.query(query);
  }

  /**
   * Êé•Á∂öÁµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getConnectionStats() {
    if (!this.pool) {
      return { connected: false };
    }

    return {
      connected: true,
      totalCount: this.pool.totalCount,
      idleCount: this.pool.idleCount,
      waitingCount: this.pool.waitingCount
    };
  }

  /**
   * PostgreSQLÂõ∫Êúâ„ÅÆÊúÄÈÅ©Âåñ„Åï„Çå„Åü„ÇØ„Ç®„É™„ÇíÂÆüË°å
   */
  async optimizedQuery(operation, params) {
    switch (operation) {
      case 'fullTextSearch':
        return await this._fullTextSearch(params);
      case 'jsonQuery':
        return await this._jsonQuery(params);
      case 'arrayQuery':
        return await this._arrayQuery(params);
      case 'explain':
        return await this._explainQuery(params);
      default:
        throw new Error(`Êú™ÂØæÂøú„ÅÆÊìç‰Ωú: ${operation}`);
    }
  }

  /**
   * ÂÖ®ÊñáÊ§úÁ¥¢
   * @private
   */
  async _fullTextSearch({ table, columns, searchTerm, language = 'english' }) {
    const columnList = Array.isArray(columns) ? columns.join(' || \' \' || ') : columns;
    const query = `
      SELECT *, ts_rank(to_tsvector($1, ${columnList}), plainto_tsquery($1, $2)) as rank
      FROM ${table}
      WHERE to_tsvector($1, ${columnList}) @@ plainto_tsquery($1, $2)
      ORDER BY rank DESC
    `;
    
    return await this.query(query, [language, searchTerm]);
  }

  /**
   * JSON „ÇØ„Ç®„É™
   * @private
   */
  async _jsonQuery({ table, column, path, value, operator = '@>' }) {
    const query = `
      SELECT * FROM ${table}
      WHERE ${column} ${operator} $1
    `;
    
    const jsonValue = typeof value === 'string' ? value : JSON.stringify(value);
    return await this.query(query, [jsonValue]);
  }

  /**
   * ÈÖçÂàó„ÇØ„Ç®„É™
   * @private
   */
  async _arrayQuery({ table, column, values, operator = '&&' }) {
    const query = `
      SELECT * FROM ${table}
      WHERE ${column} ${operator} $1
    `;
    
    return await this.query(query, [values]);
  }

  /**
   * „ÇØ„Ç®„É™ÂÆüË°åË®àÁîª„ÅÆÂèñÂæó
   * @private
   */
  async _explainQuery({ query, params = [], analyze = false }) {
    const explainQuery = `EXPLAIN ${analyze ? 'ANALYZE' : ''} ${query}`;
    return await this.query(explainQuery, params);
  }

  /**
   * „Çπ„Ç≠„Éº„ÉûÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getSchema(tableName) {
    const query = `
      SELECT 
        column_name,
        data_type,
        is_nullable,
        column_default,
        character_maximum_length
      FROM information_schema.columns
      WHERE table_name = $1
      AND table_schema = 'public'
      ORDER BY ordinal_position
    `;
    
    const result = await this.query(query, [tableName]);
    return result.rows;
  }

  /**
   * „Éá„Éº„Çø„Éô„Éº„ÇπÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getDatabaseInfo() {
    const versionQuery = 'SELECT version()';
    const sizeQuery = `
      SELECT pg_size_pretty(pg_database_size(current_database())) as size
    `;
    const tablesQuery = `
      SELECT COUNT(*) as table_count
      FROM information_schema.tables
      WHERE table_schema = 'public'
    `;

    const [version, size, tables] = await Promise.all([
      this.query(versionQuery),
      this.query(sizeQuery),
      this.query(tablesQuery)
    ]);

    return {
      version: version.rows[0].version,
      size: size.rows[0].size,
      tableCount: parseInt(tables.rows[0].table_count),
      adapter: 'PostgreSQL'
    };
  }

  /**
   * „Éá„Éº„ÇøÂûã„ÇíPostgreSQLÂΩ¢Âºè„Å´Â§âÊèõ
   * @private
   */
  _convertDataType(definition) {
    const type = definition.type?.toUpperCase() || 'TEXT';
    const constraints = definition.constraints || {};
    
    let pgType;
    switch (type) {
      case 'STRING':
        pgType = definition.length ? `VARCHAR(${definition.length})` : 'TEXT';
        break;
      case 'INTEGER':
        pgType = constraints.autoIncrement ? 'SERIAL' : 'INTEGER';
        break;
      case 'BIGINT':
        pgType = constraints.autoIncrement ? 'BIGSERIAL' : 'BIGINT';
        break;
      case 'FLOAT':
        pgType = 'REAL';
        break;
      case 'DOUBLE':
        pgType = 'DOUBLE PRECISION';
        break;
      case 'DECIMAL':
        pgType = definition.precision ? 
          `DECIMAL(${definition.precision}, ${definition.scale || 0})` : 'DECIMAL';
        break;
      case 'BOOLEAN':
        pgType = 'BOOLEAN';
        break;
      case 'DATE':
        pgType = 'TIMESTAMP WITH TIME ZONE';
        break;
      case 'DATEONLY':
        pgType = 'DATE';
        break;
      case 'JSON':
        pgType = 'JSON';
        break;
      case 'JSONB':
        pgType = 'JSONB';
        break;
      case 'UUID':
        pgType = 'UUID';
        break;
      case 'TEXT':
      default:
        pgType = 'TEXT';
    }

    // Âà∂Á¥Ñ„ÅÆËøΩÂä†
    const constraintList = [];
    if (constraints.primaryKey) constraintList.push('PRIMARY KEY');
    if (constraints.unique) constraintList.push('UNIQUE');
    if (constraints.allowNull === false) constraintList.push('NOT NULL');
    if (constraints.defaultValue !== undefined) {
      constraintList.push(`DEFAULT ${this._formatDefaultValue(constraints.defaultValue)}`);
    }

    return `${pgType} ${constraintList.join(' ')}`.trim();
  }

  /**
   * „Éá„Éï„Ç©„É´„ÉàÂÄ§„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà
   * @private
   */
  _formatDefaultValue(value) {
    if (value === null) return 'NULL';
    if (typeof value === 'string') return `'${value}'`;
    if (typeof value === 'boolean') return value.toString();
    if (typeof value === 'number') return value.toString();
    return `'${value}'`;
  }

  /**
   * „ÇØ„Ç®„É™„Éì„É´„ÉÄ„Éº„ÇíÂèñÂæó
   */
  getQueryBuilder() {
    return new QueryBuilder(this);
  }
}

module.exports = PostgreSQLAdapter;