const DatabaseAdapter = require('./DatabaseAdapter');
const QueryBuilder = require('./QueryBuilder');

/**
 * SequelizeÁµ±Âêà„Ç¢„ÉÄ„Éó„Çø„Éº
 * 
 * Êó¢Â≠ò„ÅÆSequelize„Éô„Éº„Çπ„ÅÆ„É¢„Éá„É´„Å®Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„Éô„Éº„ÇπÊäΩË±°Âåñ„É¨„Ç§„É§„Éº„ÇíÊ©ãÊ∏°„Åó
 */
class SequelizeAdapter extends DatabaseAdapter {
  constructor(sequelizeInstance) {
    super({});
    this.sequelize = sequelizeInstance;
    this.isConnected = false;
    this.queryBuilder = new QueryBuilder(this);
  }

  /**
   * „Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂öÔºàÊó¢Â≠ò„ÅÆSequelizeÊé•Á∂ö„Çí‰ΩøÁî®Ôºâ
   */
  async connect() {
    try {
      await this.sequelize.authenticate();
      this.isConnected = true;
      console.log('‚úÖ SequelizeÁµ±Âêà„Ç¢„ÉÄ„Éó„Çø„ÉºÊé•Á∂öÊàêÂäü');
    } catch (error) {
      console.error('‚ùå SequelizeÁµ±Âêà„Ç¢„ÉÄ„Éó„Çø„ÉºÊé•Á∂ö„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÇíÂàáÊñ≠
   */
  async disconnect() {
    try {
      await this.sequelize.close();
      this.isConnected = false;
      console.log('‚úÖ SequelizeÁµ±Âêà„Ç¢„ÉÄ„Éó„Çø„ÉºÊé•Á∂öÂàáÊñ≠');
    } catch (error) {
      console.error('‚ùå SequelizeÁµ±Âêà„Ç¢„ÉÄ„Éó„Çø„ÉºÂàáÊñ≠„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „ÇØ„Ç®„É™„ÇíÂÆüË°å
   */
  async query(query, params = []) {
    if (!this.sequelize) {
      throw new Error('Sequelize„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
    }

    try {
      const start = Date.now();
      const [results, metadata] = await this.sequelize.query(query, {
        replacements: params,
        type: this.sequelize.QueryTypes.RAW
      });
      const duration = Date.now() - start;

      // „É≠„Ç∞Âá∫ÂäõÔºàÈñãÁô∫Áí∞Â¢É„ÅÆ„ÅøÔºâ
      if (process.env.NODE_ENV === 'development') {
        console.log(`üîç SQLÂÆüË°å: ${duration}ms`, { query, params });
      }

      return {
        rows: Array.isArray(results) ? results : [results],
        rowCount: Array.isArray(results) ? results.length : 1,
        fields: metadata?.fields || []
      };
    } catch (error) {
      console.error('‚ùå Sequelize„ÇØ„Ç®„É™„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„ÇíÈñãÂßã
   */
  async beginTransaction() {
    const transaction = await this.sequelize.transaction();
    
    return {
      transaction,
      async commit() {
        await transaction.commit();
      },
      async rollback() {
        await transaction.rollback();
      },
      async query(sql, params) {
        const [results, metadata] = await this.sequelize.query(sql, {
          replacements: params,
          type: this.sequelize.QueryTypes.RAW,
          transaction
        });

        return {
          rows: Array.isArray(results) ? results : [results],
          rowCount: Array.isArray(results) ? results.length : 1,
          fields: metadata?.fields || []
        };
      }
    };
  }

  /**
   * „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Çí„Ç≥„Éü„ÉÉ„Éà
   */
  async commitTransaction(transaction) {
    await transaction.commit();
  }

  /**
   * „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥„Çí„É≠„Éº„É´„Éê„ÉÉ„ÇØ
   */
  async rollbackTransaction(transaction) {
    await transaction.rollback();
  }

  /**
   * „ÉÜ„Éº„Éñ„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
   */
  async tableExists(tableName) {
    try {
      const queryInterface = this.sequelize.getQueryInterface();
      const tables = await queryInterface.showAllTables();
      return tables.includes(tableName);
    } catch (error) {
      console.error('„ÉÜ„Éº„Éñ„É´Â≠òÂú®Á¢∫Ë™ç„Ç®„É©„Éº:', error.message);
      return false;
    }
  }

  /**
   * „ÉÜ„Éº„Éñ„É´„Çí‰ΩúÊàê
   */
  async createTable(tableName, schema) {
    try {
      const queryInterface = this.sequelize.getQueryInterface();
      const attributes = this._convertSchemaToSequelize(schema);
      
      await queryInterface.createTable(tableName, attributes);
    } catch (error) {
      console.error('„ÉÜ„Éº„Éñ„É´‰ΩúÊàê„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „ÉÜ„Éº„Éñ„É´„ÇíÂâäÈô§
   */
  async dropTable(tableName) {
    try {
      const queryInterface = this.sequelize.getQueryInterface();
      await queryInterface.dropTable(tableName);
    } catch (error) {
      console.error('„ÉÜ„Éº„Éñ„É´ÂâäÈô§„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí‰ΩúÊàê
   */
  async createIndex(tableName, indexName, columns, options = {}) {
    try {
      const queryInterface = this.sequelize.getQueryInterface();
      
      await queryInterface.addIndex(tableName, columns, {
        name: indexName,
        unique: options.unique || false,
        ...options
      });
    } catch (error) {
      console.error('„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰ΩúÊàê„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * Êé•Á∂öÁµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getConnectionStats() {
    if (!this.sequelize) {
      return { connected: false };
    }

    return {
      connected: this.isConnected,
      adapter: 'SequelizeAdapter',
      dialect: this.sequelize.getDialect(),
      databaseVersion: this.sequelize.getDatabaseVersion ? 
        await this.sequelize.getDatabaseVersion() : 'unknown'
    };
  }

  /**
   * SequelizeÂõ∫Êúâ„ÅÆÊúÄÈÅ©Âåñ„Åï„Çå„Åü„ÇØ„Ç®„É™„ÇíÂÆüË°å
   */
  async optimizedQuery(operation, params) {
    switch (operation) {
      case 'findAndCountAll':
        return await this._findAndCountAll(params);
      case 'bulkCreate':
        return await this._bulkCreate(params);
      case 'bulkUpdate':
        return await this._bulkUpdate(params);
      case 'bulkDestroy':
        return await this._bulkDestroy(params);
      default:
        throw new Error(`Êú™ÂØæÂøú„ÅÆÊìç‰Ωú: ${operation}`);
    }
  }

  /**
   * findAndCountAllÊìç‰Ωú
   * @private
   */
  async _findAndCountAll({ modelName, options = {} }) {
    const model = this.sequelize.models[modelName];
    if (!model) {
      throw new Error(`„É¢„Éá„É´ ${modelName} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
    }

    return await model.findAndCountAll(options);
  }

  /**
   * bulkCreateÊìç‰Ωú
   * @private
   */
  async _bulkCreate({ modelName, data, options = {} }) {
    const model = this.sequelize.models[modelName];
    if (!model) {
      throw new Error(`„É¢„Éá„É´ ${modelName} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
    }

    return await model.bulkCreate(data, options);
  }

  /**
   * bulkUpdateÊìç‰Ωú
   * @private
   */
  async _bulkUpdate({ modelName, values, options = {} }) {
    const model = this.sequelize.models[modelName];
    if (!model) {
      throw new Error(`„É¢„Éá„É´ ${modelName} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
    }

    return await model.update(values, options);
  }

  /**
   * bulkDestroyÊìç‰Ωú
   * @private
   */
  async _bulkDestroy({ modelName, options = {} }) {
    const model = this.sequelize.models[modelName];
    if (!model) {
      throw new Error(`„É¢„Éá„É´ ${modelName} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
    }

    return await model.destroy(options);
  }

  /**
   * „Çπ„Ç≠„Éº„ÉûÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getSchema(tableName) {
    try {
      const queryInterface = this.sequelize.getQueryInterface();
      const tableInfo = await queryInterface.describeTable(tableName);
      
      return Object.entries(tableInfo).map(([columnName, columnInfo]) => ({
        column_name: columnName,
        data_type: columnInfo.type,
        is_nullable: columnInfo.allowNull ? 'YES' : 'NO',
        column_default: columnInfo.defaultValue,
        primary_key: columnInfo.primaryKey || false
      }));
    } catch (error) {
      console.error('„Çπ„Ç≠„Éº„ÉûÊÉÖÂ†±ÂèñÂæó„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Éá„Éº„Çø„Éô„Éº„ÇπÊÉÖÂ†±„ÇíÂèñÂæó
   */
  async getDatabaseInfo() {
    try {
      const dialect = this.sequelize.getDialect();
      const version = this.sequelize.getDatabaseVersion ? 
        await this.sequelize.getDatabaseVersion() : 'unknown';
      
      // ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„É¢„Éá„É´Êï∞„ÇíÂèñÂæó
      const modelCount = Object.keys(this.sequelize.models).length;

      return {
        version: `${dialect} ${version}`,
        dialect,
        modelCount,
        adapter: 'SequelizeAdapter'
      };
    } catch (error) {
      console.error('„Éá„Éº„Çø„Éô„Éº„ÇπÊÉÖÂ†±ÂèñÂæó„Ç®„É©„Éº:', error.message);
      throw error;
    }
  }

  /**
   * „Çπ„Ç≠„Éº„Éû„ÇíSequelizeÂΩ¢Âºè„Å´Â§âÊèõ
   * @private
   */
  _convertSchemaToSequelize(schema) {
    const attributes = {};
    
    Object.entries(schema).forEach(([name, definition]) => {
      const sequelizeType = this._convertTypeToSequelize(definition.type);
      const constraints = definition.constraints || {};
      
      attributes[name] = {
        type: sequelizeType,
        allowNull: constraints.allowNull !== false,
        primaryKey: constraints.primaryKey || false,
        autoIncrement: constraints.autoIncrement || false,
        unique: constraints.unique || false,
        defaultValue: constraints.defaultValue
      };
    });
    
    return attributes;
  }

  /**
   * „Éá„Éº„ÇøÂûã„ÇíSequelizeÂΩ¢Âºè„Å´Â§âÊèõ
   * @private
   */
  _convertTypeToSequelize(type) {
    const DataTypes = this.sequelize.Sequelize.DataTypes;
    
    switch (type?.toUpperCase()) {
      case 'STRING':
        return DataTypes.STRING;
      case 'TEXT':
        return DataTypes.TEXT;
      case 'INTEGER':
        return DataTypes.INTEGER;
      case 'BIGINT':
        return DataTypes.BIGINT;
      case 'FLOAT':
        return DataTypes.FLOAT;
      case 'DOUBLE':
        return DataTypes.DOUBLE;
      case 'DECIMAL':
        return DataTypes.DECIMAL;
      case 'BOOLEAN':
        return DataTypes.BOOLEAN;
      case 'DATE':
        return DataTypes.DATE;
      case 'DATEONLY':
        return DataTypes.DATEONLY;
      case 'JSON':
        return DataTypes.JSON;
      case 'JSONB':
        return DataTypes.JSONB;
      case 'UUID':
        return DataTypes.UUID;
      default:
        return DataTypes.STRING;
    }
  }

  /**
   * Sequelize„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæó
   */
  getSequelizeInstance() {
    return this.sequelize;
  }

  /**
   * „É¢„Éá„É´„ÇíÂèñÂæó
   */
  getModel(modelName) {
    return this.sequelize.models[modelName];
  }

  /**
   * ÂÖ®„É¢„Éá„É´„ÇíÂèñÂæó
   */
  getAllModels() {
    return this.sequelize.models;
  }

  /**
   * „ÇØ„Ç®„É™„Éì„É´„ÉÄ„Éº„ÇíÂèñÂæó
   */
  getQueryBuilder() {
    return new QueryBuilder(this);
  }
}

module.exports = SequelizeAdapter;