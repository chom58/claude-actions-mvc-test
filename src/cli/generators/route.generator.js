const fs = require('fs').promises;
const path = require('path');
const { camelCase, kebabCase } = require('change-case');

/**
 * ルートジェネレーター
 */
class RouteGenerator {
  constructor() {
    this.srcDir = path.join(process.cwd(), 'src');
  }

  /**
   * ルートを生成
   */
  async generate(name, options = {}) {
    const routeName = camelCase(name) + 'Routes';
    const urlPath = options.prefix || `/${kebabCase(name)}`;
    
    // ディレクトリの確認・作成
    const routesDir = path.join(this.srcDir, 'routes');
    await this.ensureDirectory(routesDir);
    
    // ルートファイルのパス
    const routePath = path.join(routesDir, `${routeName}.js`);
    
    // ファイルが既に存在するかチェック
    if (await this.fileExists(routePath)) {
      throw new Error(`ルート ${routeName} は既に存在します`);
    }
    
    // ルートテンプレートの生成
    const routeTemplate = this.getRouteTemplate(name, options);
    
    // ファイルの生成
    await fs.writeFile(routePath, routeTemplate);
    
    return {
      routePath: this.getRelativePath(routePath),
      routeName,
      mountPath: urlPath,
      requirePath: `./src/routes/${routeName}`
    };
  }

  /**
   * ルートテンプレート
   */
  getRouteTemplate(name, options) {
    const methods = options.methods || ['GET', 'POST'];
    const middleware = options.middleware || [];
    
    // ミドルウェアのインポート
    const middlewareImports = this.generateMiddlewareImports(middleware);
    
    // ルート定義
    const routeDefinitions = this.generateRouteDefinitions(name, methods, middleware);
    
    // バリデーション
    const validations = this.generateValidations(name, methods);
    
    return `const express = require('express');
const router = express.Router();
${middlewareImports}
${validations.imports}

/**
 * ${name} ルート
 * 
 * Generated by MVC CLI
 */

${validations.definitions}

${routeDefinitions}

module.exports = router;`;
  }

  /**
   * ミドルウェアのインポート生成
   */
  generateMiddlewareImports(middleware) {
    const imports = [];
    
    if (middleware.includes('auth')) {
      imports.push("const { authenticate } = require('../middleware/auth');");
    }
    
    if (middleware.includes('rateLimit')) {
      imports.push("const { rateLimit } = require('../middleware/rateLimit');");
    }
    
    if (middleware.includes('upload')) {
      imports.push("const upload = require('../middleware/upload');");
    }
    
    if (middleware.includes('validation')) {
      imports.push("const { body, param, query, validationResult } = require('express-validator');");
    }
    
    return imports.join('\n');
  }

  /**
   * ルート定義の生成
   */
  generateRouteDefinitions(name, methods, middleware) {
    const definitions = [];
    
    methods.forEach(method => {
      const middlewareChain = this.buildMiddlewareChain(method, middleware);
      const handler = this.generateHandler(name, method);
      
      switch (method) {
        case 'GET':
          definitions.push(`// ${name}の取得
router.get('/'${middlewareChain}, ${handler});

// 個別の${name}取得
router.get('/:id'${middlewareChain}, ${handler}ById);`);
          break;
          
        case 'POST':
          definitions.push(`// ${name}の作成
router.post('/'${middlewareChain}, create${camelCase(name, { pascalCase: true })}Validation, ${handler});`);
          break;
          
        case 'PUT':
          definitions.push(`// ${name}の更新
router.put('/:id'${middlewareChain}, update${camelCase(name, { pascalCase: true })}Validation, ${handler});`);
          break;
          
        case 'PATCH':
          definitions.push(`// ${name}の部分更新
router.patch('/:id'${middlewareChain}, patch${camelCase(name, { pascalCase: true })}Validation, ${handler});`);
          break;
          
        case 'DELETE':
          definitions.push(`// ${name}の削除
router.delete('/:id'${middlewareChain}, ${handler});`);
          break;
      }
    });
    
    return definitions.join('\n\n');
  }

  /**
   * ミドルウェアチェーンの構築
   */
  buildMiddlewareChain(method, middleware) {
    const chain = [];
    
    // 認証が必要な場合
    if (middleware.includes('auth')) {
      chain.push('authenticate');
    }
    
    // レート制限
    if (middleware.includes('rateLimit')) {
      chain.push('rateLimit()');
    }
    
    // ファイルアップロード
    if (middleware.includes('upload') && (method === 'POST' || method === 'PUT')) {
      chain.push('upload.single("file")');
    }
    
    return chain.length > 0 ? ', ' + chain.join(', ') : '';
  }

  /**
   * ハンドラーの生成
   */
  generateHandler(name, method) {
    const baseName = camelCase(name);
    
    const handlers = {
      'GET': `async (req, res, next) => {
  try {
    // TODO: ${name}の取得ロジックを実装
    res.json({
      success: true,
      data: [],
      message: '${name}を取得しました'
    });
  } catch (error) {
    next(error);
  }
}`,
      'POST': `async (req, res, next) => {
  try {
    // バリデーションエラーチェック
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }
    
    // TODO: ${name}の作成ロジックを実装
    res.status(201).json({
      success: true,
      data: req.body,
      message: '${name}を作成しました'
    });
  } catch (error) {
    next(error);
  }
}`,
      'PUT': `async (req, res, next) => {
  try {
    // バリデーションエラーチェック
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }
    
    // TODO: ${name}の更新ロジックを実装
    res.json({
      success: true,
      data: req.body,
      message: '${name}を更新しました'
    });
  } catch (error) {
    next(error);
  }
}`,
      'DELETE': `async (req, res, next) => {
  try {
    // TODO: ${name}の削除ロジックを実装
    res.json({
      success: true,
      message: '${name}を削除しました'
    });
  } catch (error) {
    next(error);
  }
}`
    };
    
    return handlers[method] || handlers['GET'];
  }

  /**
   * バリデーションの生成
   */
  generateValidations(name, methods) {
    const validations = {
      imports: '',
      definitions: ''
    };
    
    if (!methods.includes('POST') && !methods.includes('PUT') && !methods.includes('PATCH')) {
      return validations;
    }
    
    validations.imports = "const { body, param, validationResult } = require('express-validator');";
    
    const definitions = [];
    
    if (methods.includes('POST')) {
      definitions.push(`// ${name}作成時のバリデーション
const create${camelCase(name, { pascalCase: true })}Validation = [
  body('name').notEmpty().withMessage('名前は必須です'),
  body('description').optional().isLength({ max: 500 }).withMessage('説明は500文字以内で入力してください')
  // TODO: 追加のバリデーションルール
];`);
    }
    
    if (methods.includes('PUT')) {
      definitions.push(`// ${name}更新時のバリデーション
const update${camelCase(name, { pascalCase: true })}Validation = [
  param('id').isInt().withMessage('無効なIDです'),
  body('name').notEmpty().withMessage('名前は必須です'),
  body('description').optional().isLength({ max: 500 }).withMessage('説明は500文字以内で入力してください')
  // TODO: 追加のバリデーションルール
];`);
    }
    
    if (methods.includes('PATCH')) {
      definitions.push(`// ${name}部分更新時のバリデーション
const patch${camelCase(name, { pascalCase: true })}Validation = [
  param('id').isInt().withMessage('無効なIDです'),
  body('name').optional().notEmpty().withMessage('名前は必須です'),
  body('description').optional().isLength({ max: 500 }).withMessage('説明は500文字以内で入力してください')
  // TODO: 追加のバリデーションルール
];`);
    }
    
    // 個別取得用のハンドラー
    if (methods.includes('GET')) {
      definitions.push(`// 個別の${name}取得
const ${camelCase(name)}ById = async (req, res, next) => {
  try {
    const { id } = req.params;
    
    // TODO: IDによる${name}の取得ロジックを実装
    res.json({
      success: true,
      data: { id },
      message: '${name}を取得しました'
    });
  } catch (error) {
    next(error);
  }
};`);
    }
    
    validations.definitions = definitions.join('\n\n');
    
    return validations;
  }

  /**
   * ディレクトリの存在確認と作成
   */
  async ensureDirectory(dirPath) {
    try {
      await fs.access(dirPath);
    } catch {
      await fs.mkdir(dirPath, { recursive: true });
    }
  }

  /**
   * ファイルの存在確認
   */
  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 相対パスの取得
   */
  getRelativePath(absolutePath) {
    return path.relative(process.cwd(), absolutePath);
  }
}

module.exports = RouteGenerator;