const fs = require('fs').promises;
const path = require('path');
const { pascalCase, camelCase, snakeCase } = require('change-case');

/**
 * モデルジェネレーター
 */
class ModelGenerator {
  constructor() {
    this.srcDir = path.join(process.cwd(), 'src');
  }

  /**
   * モデルを生成
   */
  async generate(name, options = {}) {
    const modelName = pascalCase(name);
    const tableName = snakeCase(name) + 's';
    
    // ディレクトリの確認・作成
    const modelsDir = path.join(this.srcDir, 'models');
    await this.ensureDirectory(modelsDir);
    
    // モデルファイルのパス
    const modelPath = path.join(modelsDir, `${modelName}.js`);
    
    // ファイルが既に存在するかチェック
    if (await this.fileExists(modelPath)) {
      throw new Error(`モデル ${modelName} は既に存在します`);
    }
    
    // 属性のパース
    const attributes = this.parseAttributes(options.attributes || []);
    
    // モデルテンプレートの生成
    const modelTemplate = this.getModelTemplate(modelName, tableName, attributes, options);
    
    // ファイルの生成
    await fs.writeFile(modelPath, modelTemplate);
    
    const result = {
      modelPath: this.getRelativePath(modelPath),
      modelName
    };
    
    // マイグレーションの生成（オプション）
    if (options.migration !== false) {
      const migrationResult = await this.generateMigration(modelName, tableName, attributes, options);
      result.migrationPath = migrationResult.migrationPath;
    }
    
    // モデルをmodels/index.jsに登録
    await this.registerModel(modelName);
    
    return result;
  }

  /**
   * 属性のパース
   */
  parseAttributes(attributeStrings) {
    return attributeStrings.map(attrString => {
      const parts = attrString.split(':');
      const name = parts[0];
      const type = parts[1] || 'STRING';
      const constraints = parts.slice(2);
      
      const attribute = {
        name: camelCase(name),
        type: type.toUpperCase(),
        constraints: {}
      };
      
      // 制約の解析
      constraints.forEach(constraint => {
        switch (constraint.toLowerCase()) {
          case 'required':
          case 'notnull':
            attribute.constraints.allowNull = false;
            break;
          case 'unique':
            attribute.constraints.unique = true;
            break;
          case 'primarykey':
            attribute.constraints.primaryKey = true;
            break;
          case 'autoincrement':
            attribute.constraints.autoIncrement = true;
            break;
          default:
            if (constraint.startsWith('default:')) {
              attribute.constraints.defaultValue = constraint.split(':')[1];
            }
        }
      });
      
      return attribute;
    });
  }

  /**
   * モデルテンプレート
   */
  getModelTemplate(modelName, tableName, attributes, options) {
    const attributeDefinitions = attributes.map(attr => {
      const constraints = Object.entries(attr.constraints)
        .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
        .join(',\n      ');
      
      return `    ${attr.name}: {
      type: DataTypes.${attr.type}${constraints ? ',\n      ' + constraints : ''}
    }`;
    }).join(',\n');
    
    const associations = this.generateAssociations(modelName, options);
    const hooks = this.generateHooks(modelName, options);
    const scopes = this.generateScopes(modelName, options);
    const instanceMethods = this.generateInstanceMethods(modelName, options);
    const classMethods = this.generateClassMethods(modelName, options);
    
    return `const { DataTypes } = require('sequelize');

/**
 * ${modelName}モデル
 * 
 * Generated by MVC CLI
 */
module.exports = (sequelize) => {
  const ${modelName} = sequelize.define('${modelName}', {
${attributeDefinitions}
  }, {
    tableName: '${tableName}',
    timestamps: ${options.timestamps !== false},
    paranoid: ${options.paranoid || false},
    underscored: true,
    indexes: [
      // インデックスの定義
      ${attributes
        .filter(attr => attr.constraints.unique || attr.constraints.index)
        .map(attr => `{ fields: ['${snakeCase(attr.name)}'] }`)
        .join(',\n      ')}
    ]${scopes ? ',\n    scopes: ' + scopes : ''}
  });

  ${associations}

  ${hooks}

  ${instanceMethods}

  ${classMethods}

  return ${modelName};
};`;
  }

  /**
   * アソシエーションの生成
   */
  generateAssociations(modelName, options) {
    const associations = [];
    
    // デフォルトのアソシエーション（Userモデルとの関連など）
    if (options.belongsToUser !== false && modelName !== 'User') {
      associations.push(`    ${modelName}.belongsTo(models.User, {
      foreignKey: 'userId',
      as: 'user'
    });`);
    }
    
    // カスタムアソシエーション
    if (options.associations) {
      options.associations.forEach(assoc => {
        associations.push(`    ${modelName}.${assoc.type}(models.${assoc.model}, {
      foreignKey: '${assoc.foreignKey || camelCase(assoc.model) + 'Id'}',
      as: '${assoc.as || camelCase(assoc.model)}'
    });`);
      });
    }
    
    if (associations.length === 0) {
      return `// アソシエーションの定義
  ${modelName}.associate = (models) => {
    // TODO: アソシエーションを定義
  };`;
    }
    
    return `// アソシエーションの定義
  ${modelName}.associate = (models) => {
${associations.join('\n\n')}
  };`;
  }

  /**
   * フックの生成
   */
  generateHooks(modelName, options) {
    if (!options.hooks) return '';
    
    const hooks = [];
    
    if (options.paranoid) {
      hooks.push(`  // 論理削除前の処理
  ${modelName}.addHook('beforeDestroy', async (instance, options) => {
    // TODO: 削除前の処理
  });`);
    }
    
    if (options.timestamps) {
      hooks.push(`  // 更新前の処理
  ${modelName}.addHook('beforeUpdate', async (instance, options) => {
    // TODO: 更新前の処理
  });`);
    }
    
    return hooks.join('\n\n');
  }

  /**
   * スコープの生成
   */
  generateScopes(modelName, options) {
    if (!options.scopes && !options.paranoid) return null;
    
    const scopes = {};
    
    // デフォルトスコープ
    if (options.defaultScope) {
      scopes.defaultScope = options.defaultScope;
    }
    
    // 共通スコープ
    scopes.active = {
      where: { isActive: true }
    };
    
    scopes.recent = {
      order: [['createdAt', 'DESC']]
    };
    
    if (options.belongsToUser !== false) {
      scopes.byUser = (userId) => ({
        where: { userId }
      });
    }
    
    return JSON.stringify(scopes, null, 4).replace(/"([^"]+)":/g, '$1:');
  }

  /**
   * インスタンスメソッドの生成
   */
  generateInstanceMethods(modelName, options) {
    const methods = [];
    
    // 基本的なメソッド
    methods.push(`  // JSONレスポンス用のフォーマット
  ${modelName}.prototype.toJSON = function() {
    const values = { ...this.get() };
    
    // パスワードなどのセンシティブな情報を除外
    delete values.password;
    delete values.deletedAt;
    
    return values;
  };`);
    
    if (options.instanceMethods) {
      options.instanceMethods.forEach(method => {
        methods.push(`  // ${method.description || method.name}
  ${modelName}.prototype.${method.name} = async function(${method.params || ''}) {
    // TODO: ${method.name}の実装
  };`);
      });
    }
    
    return methods.join('\n\n');
  }

  /**
   * クラスメソッドの生成
   */
  generateClassMethods(modelName, options) {
    const methods = [];
    
    // 検索用メソッド
    methods.push(`  // 検索メソッド
  ${modelName}.search = async function(query, options = {}) {
    const { page = 1, limit = 10 } = options;
    
    return this.findAndCountAll({
      where: {
        // TODO: 検索条件の実装
      },
      limit,
      offset: (page - 1) * limit,
      order: [['createdAt', 'DESC']]
    });
  };`);
    
    if (options.classMethods) {
      options.classMethods.forEach(method => {
        methods.push(`  // ${method.description || method.name}
  ${modelName}.${method.name} = async function(${method.params || ''}) {
    // TODO: ${method.name}の実装
  };`);
      });
    }
    
    return methods.join('\n\n');
  }

  /**
   * マイグレーションファイルを生成
   */
  async generateMigration(modelName, tableName, attributes, options) {
    const migrationsDir = path.join(this.srcDir, 'migrations');
    await this.ensureDirectory(migrationsDir);
    
    const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
    const migrationName = `${timestamp}-create-${tableName}.js`;
    const migrationPath = path.join(migrationsDir, migrationName);
    
    const migrationTemplate = this.getMigrationTemplate(tableName, attributes, options);
    await fs.writeFile(migrationPath, migrationTemplate);
    
    return {
      migrationPath: this.getRelativePath(migrationPath)
    };
  }

  /**
   * マイグレーションテンプレート
   */
  getMigrationTemplate(tableName, attributes, options) {
    const columnDefinitions = attributes.map(attr => {
      const column = {
        type: `Sequelize.${attr.type}`,
        ...attr.constraints
      };
      
      return `      ${snakeCase(attr.name)}: {
        type: ${column.type}${Object.keys(attr.constraints).length > 0 ? ',' : ''}
${Object.entries(attr.constraints)
  .map(([key, value]) => `        ${key}: ${JSON.stringify(value)}`)
  .join(',\n')}
      }`;
    }).join(',\n');
    
    // タイムスタンプの追加
    const timestamps = options.timestamps !== false ? `,
      created_at: {
        type: Sequelize.DATE,
        allowNull: false
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false
      }` : '';
    
    // 論理削除カラムの追加
    const paranoid = options.paranoid ? `,
      deleted_at: {
        type: Sequelize.DATE,
        allowNull: true
      }` : '';
    
    return `'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('${tableName}', {
      id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        allowNull: false
      },
${columnDefinitions}${timestamps}${paranoid}
    });
    
    // インデックスの追加
    ${attributes
      .filter(attr => attr.constraints.unique)
      .map(attr => `await queryInterface.addIndex('${tableName}', ['${snakeCase(attr.name)}'], {
      unique: true,
      name: '${tableName}_${snakeCase(attr.name)}_unique'
    });`)
      .join('\n    ')}
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('${tableName}');
  }
};`;
  }

  /**
   * モデルをindex.jsに登録
   */
  async registerModel(modelName) {
    const indexPath = path.join(this.srcDir, 'models', 'index.js');
    
    try {
      let content = await fs.readFile(indexPath, 'utf-8');
      
      // 既に登録されているかチェック
      if (content.includes(`/${modelName}.js`)) {
        return;
      }
      
      // モデルのインポートを追加
      const modelRequire = `  ${modelName}: require('./${modelName}')(sequelize),`;
      
      // modelsオブジェクトに追加
      const modelsRegex = /const models = \{([^}]+)\};/s;
      const match = content.match(modelsRegex);
      
      if (match) {
        const modelsContent = match[1];
        const updatedModels = modelsContent.trimEnd() + '\n' + modelRequire;
        content = content.replace(modelsRegex, `const models = {${updatedModels}\n};`);
        
        await fs.writeFile(indexPath, content);
      }
    } catch (error) {
      console.warn('models/index.jsへの自動登録に失敗しました。手動で追加してください。');
    }
  }

  /**
   * ディレクトリの存在確認と作成
   */
  async ensureDirectory(dirPath) {
    try {
      await fs.access(dirPath);
    } catch {
      await fs.mkdir(dirPath, { recursive: true });
    }
  }

  /**
   * ファイルの存在確認
   */
  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 相対パスの取得
   */
  getRelativePath(absolutePath) {
    return path.relative(process.cwd(), absolutePath);
  }
}

module.exports = ModelGenerator;